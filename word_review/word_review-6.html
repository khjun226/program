<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    void 포인터와 malloc, gcc의 컴파일 과정: void 포인터는 어떤 타입의 메모리 블록도 가리킬 수 있는 일반적인 포인터입니다. 
                                                   즉, 포인터가 가리키는 값의 데이터 형식을 지정하지 않습니다. 이러한 특성으로 인해, void 포인터는 일반적으로 콜백 기능과 함수 포인터 등에서 유용하게 사용됩니다. 
                                                   malloc() 함수는 C와 C++에서 메모리를 동적으로 할당하기 위해 사용되는 함수입니다. 이 함수는 void 형식으로 할당된 메모리 블록의 포인터를 반환합니다. 
                                                   malloc() 함수는 할당할 메모리의 크기를 인자로 전달받으며, 할당 된 메모리는 실행 시간에 결정됩니다. 
                                                   malloc() 함수는 사용 후 free()함수를 통해 메모리 해제를 수행해야 하므로 올바른 메모리 관리가 필요합니다. GCC의 컴파일 과정은 다음과 같은 단계를 거칩니다.
                                                   전처리 과정: Preprocessor가 소스 코드를 분석하여, 헤더 파일을 참조하거나, 매크로를 확장합니다.
                                                   컴파일:  전처리된 소스 코드를 컴파일하여 어셈블리어 형식으로 변환합니다.
                                                   어셈블: 어셈블리어 형식의 소스 코드를 오브젝트 파일 형식(목적 파일 형식)으로 변환합니다.
                                                   링크: 여러 오브젝트 파일을 하나로 합쳐 최종 실행파일을 생성합니다.
                                                   이러한 단계를 거쳐 컴파일된 소스 코드가 최종 실행 파일로 변환됩니다. 이 과정에서 void 포인터와 malloc() 함수는 메모리 동적 할당에 사용되며, 프로그램의 유연성을 높이는 데에 큰 역할을 합니다.

nasm과 AT&T: NASM은 크로스 플랫폼 어셈블러로, 80x86 및 x86-64 아키텍처의 윈도우, 리눅스, 맥 OS X 등에서 사용됩니다.
                   NASM은 AT&T 구문보다 인기가 있습니다. AT&T 구문은 초기 UNIX 시스템에서 널리 사용된 어셈블리어 구문입니다. 
                   이 구문은 계산의 방향과 크기에 대한 정보가 소스 코드에 명시적으로 표시되어 있습니다. 따라서 코드의 가독성이 떨어지고 이해하기 어려워지지만,
                   이해하기 쉬운 C 프로그래밍 언어의 구문을 차용하여 CPU 정보 등을 포함하게 되어 있습니다. 
                   NASM은 AT&T와는 달리, 기본적으로 Intel 구문을 따르며, 명령을 읽고 이해하기 쉬운 구문으로 더 많은 정보를 제공합니다. 
                   이러한 간결성은 디버깅, 코드 해석 및 이해 등을 최적화할 수 있습니다. 
                   NASM은 수학적 계산과 부동 소수점 조작, 그리고 C++ 및 다른 프로그래밍 컴파일러와 같은 다른 목적을 쉽게 수행할 수 있습니다. 
                   요약하자면, AT&T 구문은 초기 버전에서 널리 사용되었으며, NASM은 Intel 구문을 따릅니다. 
                   NASM은 쓰기 쉽고 인기 있으며, 계산 방향과 크기 정보가 명시적인 AT&T 구문보다 더 간결합니다.

빅 엔디안과 리틀 엔디안: 빅 엔디안과 리틀 엔디안은 데이터 표현방식의 차이입니다. 
                               빅 엔디안은 가장 높은 자리(최상위 바이트)부터 데이터를 나열하는 방식입니다. 
                               즉, 데이터의 큰 부분에서 작은 부분으로 이동합니다. 예를 들어, 0x12345678을 빅 엔디안으로 표현하면 "12 34 56 78"과 같이 됩니다. 
                               리틀 엔디안은 가장 낮은 자리(최하위 바이트)부터 데이터를 나열하는 방식입니다. 즉, 데이터의 작은 부분에서 큰 부분으로 이동합니다. 
                               예를 들어, 0x12345678을 리틀 엔디안으로 표현하면 "78 56 34 12"와 같이 됩니다. 모든 컴퓨터는 빅 엔디안 또는 리틀 엔디안 중 하나를 사용합니다. 
                               앞선 설명대로, 빅 엔디안과 리틀 엔디안은 데이터를 나열하는 순서에 차이가 있습니다. 
                               이러한 차이점은 네트워크 프로토콜, 화일 형식 및 프로그래밍 언어 등에서 중요한 역할을 합니다. 
                               예를 들어, 인터넷에서 데이터를 전송할 때는 일반적으로 빅 엔디안 방식이 사용되며, x86 아키텍처에서 사용되는 리틀 엔디안 방식이 워드 및 더블워드나 리틀 엔디안 CPU 레지스터 값을 검색할 때 사용됩니다. 
                               따라서, 데이터 표현 방식이 서로 호환되지 않아 문제가 발생할 수 있으므로 프로그래밍할 때는 데이터 표현 방식에 대해 알고 있어야합니다.

C인라인 어셈블리: C언어에서 인라인 어셈블리(Inline assembly)는 C 코드에 직접 어셈블리 코드를 삽입하는 방식입니다. 
                       인라인 어셈블리는 어셈블리 코드를 함수의 C 코드 내에 직접 삽입함으로써 프로그램의 속도를 높일 수 있으며, 특정 작업을 수행하는 데 어셈블리어의 기능을 활용할 수 있습니다.
                       C 언어는 일반적으로 플랫폼 독립적인 이식성을 가지고 있지만, 인라인 어셈블리는 특정 아키텍처에 종속되어 있기 때문에 플랫폼 간 이식성이 떨어질 수 있습니다. 
                       또한, C언어에서 인라인 어셈블리는 일반적인 C코드보다 읽기 및 유지보수가 어렵게 될 수 있습니다. 
                       따라서, 주로 성능을 개선하기 위해 하드웨어와 직접적으로 상호작용해야하는 코드에서 사용됩니다.
                       인라인 어셈블리는 컴파일러 최적화를 방해할 수 있고, 특정 아키텍처에 대한 종속성으로 인해 이식성이 떨어질 수 있습니다.
                       그리고 직접적인 CPU 상호작용으로 오류를 발생시킬 수 있습니다. 따라서, 이러한 사항을 고려하여 인라인 어셈블리를 적용해야 합니다.

치트엔진과 인증크랙의 원리: 치트 엔진과 인증 크랙은 게임 또는 소프트웨어의 작동 방식을 수정하여 원래의 제한을 우회하는 방법입니다. 
                                    치트 엔진 : 치트 엔진은 게임에서 사용되는 메모리 값을 조작하여 게임 내에서 얻을 수 있는 기능, 자원, 점수 등을 속성을 변경할 수 있는 도구입니다. 
                                                  이를 통해 게임을 원래 의도된 방식과는 다르게 진행할 수 있습니다.
                                                  치트 엔진 작동 원리는 우선 메모리 스캔을 통해 게임에서되는 특정 메모리 주소를 찾습니다. 
                                                  그 다음, 찾은 메모리 주소에 대한 값 변경, 프리징(변경되지 않도록 고정) 등을 수행하여 게임에서 원하는 효과를 얻습니다. 
                                                  치트 엔진은 게임의 수정을 위한 목적이지만, 저작권 침해나 불법적인 용도로 사용될 수 있으며 게임 제작사의 정책에 따라 사용이 제한될 수 있습니다.
                                    인증 크랙 : 인증 크랙은 소프트웨어의 보안 및 인증 메커니즘을 우회하거나 제하는 방식입니다. 
                                                  인증 크랙을 통해 정품 인증, 라이선스 결제, 기능 제한 등을 무력화할 수 있습니다.
                                                  크랙 작동 원리는 라이선스 체크, 시리얼 키 입력, 기타 인증 매커니즘을 조작하거나 제거하여 소프트웨어의 기능을 제한 없이 사용하는입니다. 
                                                  이는 보안 및 인증 컴포넌트에 침투하여 소스 코드를 수정하거나 리버스 엔지니어링을 통해 원래도된 방식과 다르게 동작하도록 합니다. 
                                                  인증 크랙은 불법적이며, 저작권 침해에 해당하므로 크래커들에 의해 사용되는 데 제한되어야 합니다. 
                                   치트 엔진과 인 크랙 모두 게임과 소프트웨어 원래의 작동 방식을 수정하는데 사용되며, 각각의 목적과 작동 원리는 다릅니다. 
                                   그러나 이 두 가지 방법 모두 원작자의 의도나 저작권을 침해할 수 있는 데 주의해야 합니다.

CPU스케쥴링과 상태전이도: 	CPU 스케줄링(CPU Scheduling)은 운영체제에서 프로세스의 실행 순서를 관리하는 메커니즘입니다. 
                                    시스템에는 여러 프로세스가 동시에 실행되어야 할 때가 있기 때문에 CPU의 시간과 리소스를 효과적으로 분배하고, 다양한 프로세스가 공정하게 실행되도록 하는 역할을 합니다. 
                                    CPU 스케줄링 알고리즘에는 다음과 같은 방식들이 있습니다:
                                                                      First-Come, First-Served (FCFS) - 먼저 도착한 프로세스가 먼저 처리됩니다.
                                                                      Shortest Job Next (SJN) - 가장 짧은 작업 시간이 예상되는 프로세스가 먼저 처리됩니다.
                                                                      Priority Scheduling - 각 프로세스에 우선순위를 부여하여 높은 우선순위 프로세스가 먼저 처리됩니다.
                                                                      Round Robin (RR) - 일정 시간 간격으로 프로세스를 처리하여 누구에게나 공평하게 CPU 사용 시간을 제공합니다.
                                                                      Multilevel Queue Scheduling - 프로세스를 단계별로 분류한 큐에서 우선순위에 따라 처리합니다.
                                                                      Multilevel Feedback Queue Scheduling - 프로세스의 실적에 따라 동적으로 우선순위를 조정하여 처리합니다.
                                   상태 전이도는 프로세스가 실행되며 겪는 다양한 상태와 상태 간의 전이와정를 표현하는 도표입니다. 프로세스가 생명주기 동안 다음과 같은 상태와 전이를 겪습니다:
                                                                      새로운 상태(New) : 새로 생성된 프로세스는 이 상태에 있습니다.
                                                                      준비 상태(Ready) : 프로세스가 CPU를 할당받기를 기다리며, CPU 스케줄러에 의해 관리되는 상태입니다.
                                                                      실행중인 상태(Running) : 프로세스가 CPU를 할당받아 실행되는 상태입니다.
                                                                      대기 상태(Waiting/Blocked) : 프로세스가 I/O 작업이나 다른 이벤트의 완료에 등을 기다리는 상태입니다.
                                                                      종료 상태(Terminated) : 프로세스 실행이 완료되고, 시스템에서 관리되지 않는 상태입니다.
                                   프로세스는 이러한 상태를 전이하면서 시스템에 의해 관리되며, CPU 스케줄링은 이러한 상태 전이를 기반으로 처리되어야 할 프로세스를 결정합니다. 
                                   결국, CPU 스케쥴링과 상태 전이도는 프로세스 관리의 핵심 부분이며, 모두 효과적인 시스템 리소스 관리를 지원합니다.

서버-소켓 구조: 서버-소켓 구조는 인터넷 및 로컬 네트워크를 통해 통신하는 두 컴퓨터 사이의 연결을 설정하고 유지하는 데 사용되는 네트워크 프로그래밍 모델입니다. 
                    이 구조에서는 한 컴퓨터가 서버로 동작하며, 다른 컴퓨터가 클라이언트로 동작합니다.
                    소켓(Socket): 인터넷 프로토콜(IP) 주소와 포트 번호의 조합으로, 두 컴퓨터 사이의 통신을 가능하게 합니다. 
                                     네트워크를 통해 두 컴퓨터가 데이터를 교환하기 위해, 송신 컴퓨터와 수신 컴퓨터 사이에 소켓이 생성되어야 합니다.
                    서버(Server): 네트워크 서비스를 제공하는 컴퓨터로, 클라이언트의 요청에 응답하여 데이터나 리소스를 제공합니다. 
                                     서버는 수신 대기 소켓을 열어 클라이언트의 연결 요청을 수신합니다. 클라이언트와의 연결이 확립되면, 서버는 데이터 교환을 위한 전용 소켓을 만듭니다.
                    서버-소켓 구조는 일반적으로 아래와 같은 순서로 작동합니다:
                                     서버 소켓 생성: 서버는 수신 대기 소켓을 만들고 포트를 오픈합니다.
                                     소켓 바인딩: 서버는 생성한 소켓을 IP 주소에 바인딩합니다.
                                     수신 대기: 서버는 클라이언트의 연결 요청을 수신 대기합니다.
                                     클라이언트의 연결 요청: 클라이언트는 연결할 서버의 IP 주소와 포트를 사용하여 연결 요청을 보냅니다.
                                     연결 수락 및 데이터 전송: 서버는 클라이언트의 연결 요청을 수락하고 데이터를 전송하기 위한 전용 소켓을 생성합니다. 이후 서버와 클라이언트는 이 소켓을 통해 데이터를 교환할 수 있습니다.
                                     연결 종료: 연결이 더 이상 필요하지 않으면 서버와 클라이언트는 소켓을 닫아 연결을 종료합니다.
                    서버-소켓 구조는 많은 분산 애플리케이션과 서비스에 사용되며, 웹 서버, 이메일 서버, 데이터베이스 서버 등 다양한 서비스에 활용되고 있습니다. 
                    서버-소켓 구조는 클라이언트와 서버 간의 통신을 원활하게 하여 여러 컴퓨터가 효율적으로 데이터를 교환할 수 있도록 돕습니다.

socket 함수: socket 함수는 네트워크 프로그래밍에서 기본적인 구성요소로, 네트워크 통신을 위한 인터페이스를 제공하는 소켓을 생성하는 데 사용됩니다. 
                이 함수는 두 컴퓨터 사이의 점대점(end-to-end) 통신 채널을 설정하며, 이를 통해 데이터를 교환할 수 있습니다.
                함수 인자는 다음과 같은 세 가지가 있습니다.
                domain : 소켓의 통신 도메인을 정의합니다. 통신 도메인은 주소 체계와 프로토콜 체계를 결정합니다. 
                            일반적으로 사용되는 도메인은 AF_INET(IPv4 인터넷 프로토콜)과 AF_INET6(IPv6 인터넷 프로토콜)입니다.
                type : 소켓의 타입을 정의합니다. 소켓의 타입에는 SOCK_STREAM(연결 지향적인 스트림 소켓)과 SOCK_DGRAM(비연결 지향적인 데이터그램 소켓)이 있습니다.
                protocol : 소켓이 사용하는 프로토콜을 명시합니다. 일반적인 프로토콜로는 TCP와 UDP가 있으며, 대부분의 상황에서 이 인자는 0으로 설정하여 기본 프로토콜을 사용하도록 합니다.
                socket 함수는 성공적으로 소켓을 생성하면 소켓 파일 디스크립터를 반환하며, 실패하면 -1을 반환합니다. 
                socket 함수를 사용하여 소켓을 생성하며, 생성된 소켓을 사용하여 클라이언트와 서버 간의 네트워크 통신을 수행할 수 있습니다.

스트레스 테스트: 스트레스 테스트는 소프트웨어, 하드웨어 또는 시스템의 성능, 안정성, 가용성을 평가하기 위해 극한의 상황과 부하를 가하는 테스트 방법입니다. 
                     스트레스 테스트의 주요 목적은 시스템의 성능 한계를 확인하고, 부하가 높은 상태에서 발생할 수 있는 문제점을 찾아내어 이들 준비한다는 것입니다. 
                     스트레스 테스트는 다양한 시나리오를 포함하며, 주로 다음과 같은 테스트를 수행합니다:
                        높은 부하 테스트: 이 테스트에서는 시스템에 동시에 많은 작업을 할당하여 성능의 한계를 테스트합니다. 
                                              예를 들어, 웹 서버에 대규모 트래픽이 들어오는 경우를 시뮬레이션하여 서버가 부하를 처리할 수 있는지 확인합니다.
                        한계치 테스트: 시스템의 작업량이 지속적으로 증가하여 최대 한계치에 도달하는 경우를 시뮬레이션합니다. 이 테스트는 시스템이 최대 부하에서 패한하는지를 확인하기 위해 실행됩니다.
                        자원 한계 테스트: 시스템 상에서 사용 가능한 자원이 부족한 상황을 구현합니다. 예를 들어 적은 메모리나 CPU 사용량 등으로 인해 성능이 저하되는 경우를 확인합니다.
                    ss 스트레스 테스트를 수행하면 다음과 같은 이점이 있습니다:
                                              1. 시스템의 가용성 및 안정성을 평가할 수 있습니다.
                                              2. 어떤 문제가 발생하거나 가용성이 떨어질 때 그 원인을 찾아낼 수 있습니다.
                                              3. 시스템의 성능 한계를 판별하고, 시스템의 약점을 보완할 수 있습니다.
                     스트레스 테스트는 일반적인 성능 테스트와는 다르게, 강도 높은 부하와 극한 상황에서 시스템이 얼마나 잘 작동하는지 확인하는 데 초점을 맞추고 있습니다. 
                     이러한 테스트를 통해, 운영 중인 시스템이 잠재적인 문제에 대처하기 위한 대응책을 세울 수 있습니다.
</body>
</html>